**动态规划（Dynamic Programming, DP）**是一种通过将复杂问题分解为简单子问题，并利用子问题的解逐步构建原问题最优解的算法设计方法。其核心是**避免重复计算**，尤其适用于具有**重叠子问题**和**最优子结构**的问题。

## 一、动态规划的核心思想

### 1. **基本概念**
- **子问题（Subproblems）**：将大问题拆解为多个小问题。
- **重叠子问题（Overlapping Subproblems）**：不同的大问题可能共享相同的子问题（如斐波那契数列）。
- **最优子结构（Optimal Substructure）**：大问题的最优解由子问题的最优解组合而成。

### 2. **核心步骤**
  1. **定义状态**：明确子问题的表示方式（如 `dp[i]` 表示第 `i` 步的解）。
  2. **建立状态转移方程**：找到子问题之间的关系（递推公式）。
  3. **初始化边界条件**：确定最小子问题的解。
  4. **填表计算**：按顺序计算所有子问题的解，存储结果避免重复计算。

### 3. 动态规划的适用条件
1. **问题可分解**：能拆解为规模更小的同类子问题。  
2. **子问题重叠**：不同路径可能重复计算同一子问题。  
3. **最优子结构**：子问题的最优解能组合成原问题的最优解。

### 4. 动态规划 vs 分治法
|   **特性**   |        **动态规划**        |        **分治法**        |
| :----------: | :------------------------: | :----------------------: |
| 子问题独立性 | 子问题重叠，需存储中间结果 | 子问题独立，无需存储结果 |
|   典型问题   |   斐波那契数列、最短路径   |    归并排序、快速排序    |



## 二、经典案例详解

#### **案例 1：斐波那契数列**
- **问题**：计算第 `n` 个斐波那契数（`F(n) = F(n-1) + F(n-2)`，`F(0)=0`, `F(1)=1`）。
- **递归的缺陷**：直接递归会重复计算子问题（如 `F(3)` 被多次计算）。
- **动态规划解法**：
  1. **定义状态**：`dp[i]` 表示第 `i` 个斐波那契数。
  2. **状态转移方程**：`dp[i] = dp[i-1] + dp[i-2]`。
  3. **初始化**：`dp[0] = 0`, `dp[1] = 1`。
  4. **填表计算**：从 `i=2` 到 `n` 逐步计算，时间复杂度从指数级降至 `O(n)`。

**代码示例**：
```python
def fibonacci(n):
    if n <= 1:
        return n
    dp = [0] * (n+1)
    dp[0], dp[1] = 0, 1
    for i in range(2, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

---

#### **案例 2：跳台阶问题**
- **问题**：有 `n` 阶台阶，每次可跳 1 或 2 阶，求跳到第 `n` 阶的不同方式总数。
- **动态规划分析**：
  1. **状态定义**：`dp[i]` 表示跳到第 `i` 阶的方式数。
  2. **状态转移**：最后一步可能是从 `i-1` 跳 1 阶，或从 `i-2` 跳 2 阶。  
     ∴ `dp[i] = dp[i-1] + dp[i-2]`。
  3. **初始化**：`dp[0] = 1`（起点）, `dp[1] = 1`。
  4. **空间优化**：只需保留前两个状态，空间复杂度可降至 `O(1)`。

**代码示例**：
```python
def climb_stairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for _ in range(3, n+1):
        a, b = b, a + b
    return b
```

---

#### **案例 3：0-1背包问题**
- **问题**：给定物品重量 `weights` 和价值 `values`，背包容量 `W`，求能装入的最大价值。
- **动态规划分析**：
  1. **状态定义**：`dp[i][w]` 表示前 `i` 个物品在容量 `w` 下的最大价值。
  2. **状态转移方程**：  
     - 若不放第 `i` 个物品：`dp[i][w] = dp[i-1][w]`  
     - 若放入第 `i` 个物品：`dp[i][w] = dp[i-1][w - weights[i]] + values[i]`  
     - 最终取两者最大值。
  3. **初始化**：`dp[0][...] = 0`（无物品时价值为0）。
  4. **空间优化**：用一维数组 `dp[w]` 覆盖更新。

**代码示例**：
```python
def knapsack(W, weights, values):
    n = len(weights)
    dp = [0] * (W + 1)
    for i in range(n):
        for w in range(W, weights[i]-1, -1):
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])
    return dp[W]
```

---

### **五、动态规划的解题技巧**
1. **画表格辅助分析**：二维问题可画表格明确状态转移关系。
2. **从暴力递归入手**：先写出递归解法，再优化为动态规划。
3. **逆向思维**：如最长公共子序列（LCS）问题，从后向前推导。
4. **空间压缩**：用滚动数组或覆盖旧值减少空间复杂度。

---

### **六、总结**
动态规划通过将问题分解为子问题、存储中间结果，避免了重复计算，显著提升效率。其核心是**定义状态**和**设计状态转移方程**，需结合具体问题灵活应用。从斐波那契数列到背包问题，逐步练习可掌握其精髓。



---

### **案例详解：最长公共子序列（LCS）问题的逆向推导**
**问题描述**  
给定两个字符串 \( A = "ABCBDAB" \) 和 \( B = "BDCAB" \)，求它们的最长公共子序列（Longest Common Subsequence, LCS）。  
**注**：子序列不要求连续，但需保持字符相对顺序。

---

#### **一、逆向思维的核心**
动态规划的常规思路是“自底向上”（从前往后填表），而逆向思维则是**从后向前分解问题**，即从两个字符串的末尾字符开始比较，逐步向前推导，最终构建全局最优解。这种思路更符合人类直觉，尤其适用于递归设计。

---

#### **二、逆向推导的步骤**
##### **1. 定义状态**
设 \( \text{dp}[i][j] \) 表示字符串 \( A[0..i-1] \) 和 \( B[0..j-1] \) 的 LCS 长度。  
例如：\( \text{dp}[3][2] \) 表示 \( A[0..2] = "ABC" \) 和 \( B[0..1] = "BD" \) 的 LCS 长度。

##### **2. 状态转移方程（逆向推导）**
从后向前比较字符 \( A[i-1] \) 和 \( B[j-1] \)，分两种情况：
- **若 \( A[i-1] = B[j-1] \)**：  
  当前字符属于 LCS，结果为剩余子问题的解 +1：  
  \[
  \text{dp}[i][j] = \text{dp}[i-1][j-1] + 1
  \]
- **若 \( A[i-1] \neq B[j-1] \)**：  
  当前字符不属于 LCS，结果为两种子问题的最大值：  
  \[
  \text{dp}[i][j] = \max(\text{dp}[i-1][j], \text{dp}[i][j-1])
  \]

##### **3. 边界条件**
- 当 \( i=0 \) 或 \( j=0 \) 时，\( \text{dp}[0][j] = 0 \)、\( \text{dp}[i][0] = 0 \)。

---

#### **三、逆向推导的填表示例**
以 \( A = "ABCBDAB" \)（长度 7）和 \( B = "BDCAB" \)（长度 5）为例，构建 \( \text{dp}[8][6] \) 表格。

##### **1. 初始化边界**
|       | **0** | B    | D    | C    | A    | B    |
| ----- | ----- | ---- | ---- | ---- | ---- | ---- |
| **0** | 0     | 0    | 0    | 0    | 0    | 0    |
| **A** | 0     |      |      |      |      |      |
| **B** | 0     |      |      |      |      |      |
| **C** | 0     |      |      |      |      |      |
| **B** | 0     |      |      |      |      |      |
| **D** | 0     |      |      |      |      |      |
| **A** | 0     |      |      |      |      |      |
| **B** | 0     |      |      |      |      |      |

##### **2. 填充表格（从后向前推导）**
**步骤 1**：填充 \( i=1 \)（对应 \( A[0] = 'A' \)）：
- \( j=1 \)（\( B[0] = 'B' \)）：\( A ≠ B \)，取 \( \max(0, 0) = 0 \)
- \( j=2 \)（\( B[1] = 'D' \)）：同上，均为 0  
...  
最终行：
| **A** | 0 | 0 | 0 | 0 | 1 | 1 |

**步骤 2**：填充 \( i=2 \)（对应 \( A[1] = 'B' \)）：
- \( j=1 \)（\( B[0] = 'B' \)）：\( A = B \)，取 \( \text{dp}[1][0] + 1 = 1 \)
- \( j=2 \)（\( B[1] = 'D' \)）：\( A ≠ B \)，取 \( \max(1, 0) = 1 \)  
...  
最终行：
| **B** | 0 | 1 | 1 | 1 | 1 | 2 |

**步骤 3**：依次填充后续行，最终表格如下（仅展示关键值）：
|       | **0** | B    | D    | C    | A    | B    |
| ----- | ----- | ---- | ---- | ---- | ---- | ---- |
| **0** | 0     | 0    | 0    | 0    | 0    | 0    |
| **A** | 0     | 0    | 0    | 0    | 1    | 1    |
| **B** | 0     | 1    | 1    | 1    | 1    | 2    |
| **C** | 0     | 1    | 1    | 2    | 2    | 2    |
| **B** | 0     | 1    | 1    | 2    | 2    | 3    |
| **D** | 0     | 1    | 2    | 2    | 2    | 3    |
| **A** | 0     | 1    | 2    | 2    | 3    | 3    |
| **B** | 0     | 1    | 2    | 2    | 3    | 4    |

##### **3. 结果提取**
最大 LCS 长度为 \( \text{dp}[7][5] = 4 \)，对应的 LCS 为 **"BCAB"** 或 **"BDAB"**。

---

#### **四、逆向推导的代码实现**
```python
def longest_common_subsequence(A, B):
    m, n = len(A), len(B)
    dp = [[0] * (n+1) for _ in range(m+1)]
    
    # 从后向前填充表格
    for i in range(1, m+1):
        for j in range(1, n+1):
            if A[i-1] == B[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

# 示例
A = "ABCBDAB"
B = "BDCAB"
print(longest_common_subsequence(A, B))  # 输出 4
```

---

#### **五、逆向思维的优势**
1. **直观性**：从末尾字符开始匹配，符合“逐步缩小问题规模”的直觉。
2. **递归到动态规划的桥梁**：先通过递归理解逆向分解过程，再优化为动态规划。
3. **避免重复计算**：通过存储子问题的解，避免递归中的指数级复杂度。

---

### **总结**
在 LCS 问题中，逆向思维通过从字符串末尾向前推导，将问题分解为子问题，并利用动态规划存储中间结果，最终高效求解最长公共子序列。这种思路是动态规划中“状态转移方程设计”的典型应用，适用于多数序列对齐类问题。



**编辑距离（Edit Distance）**，也称为**莱文斯坦距离（Levenshtein Distance）**，是衡量两个字符串之间差异程度的指标。它定义为将一个字符串转换为另一个字符串所需的最少单字符编辑操作次数，允许的操作包括：**插入一个字符**、**删除一个字符**或**替换一个字符**。编辑距离广泛应用于自然语言处理（如拼写检查）、生物信息学（如DNA序列比对）等领域。

---

### **一、编辑距离的核心思想**
假设两个字符串 \( A \)（长度为 \( m \)）和 \( B \)（长度为 \( n \)），编辑距离的目标是通过最少的操作使两者相同。例如：
- 将 **"kitten"** 转换为 **"sitting"** 需要3步操作：
  1. 替换 **k→s**（"sitten"）
  2. 替换 **e→i**（"sittin"）
  3. 插入 **g**（"sitting"）

---

### **二、动态规划与编辑距离的关系**
编辑距离是动态规划（Dynamic Programming, DP）的经典问题，因其满足动态规划的两个关键特性：
1. **重叠子问题**：计算大问题的解时，会重复计算小问题的解。
2. **最优子结构**：大问题的最优解依赖于子问题的最优解。

#### **动态规划解决步骤**
1. **定义状态**  
   定义二维数组 \( dp[i][j] \) 表示将字符串 \( A[0..i-1] \) 转换为 \( B[0..j-1] \) 的最小操作次数。

2. **初始化边界条件**  
   - 当 \( A \) 为空时，\( dp[0][j] = j \)（需插入 \( j \) 次）。
   - 当 \( B \) 为空时，\( dp[i][0] = i \)（需删除 \( i \) 次）。

3. **状态转移方程**  
   根据当前字符是否相等，分两种情况：
   - **若 \( A[i-1] = B[j-1] \)**：无需操作，直接继承前一步结果：  
     \[ dp[i][j] = dp[i-1][j-1] \]
   - **若 \( A[i-1] \neq B[j-1] \)**：取三种操作的最小值 +1：  
     \[
     dp[i][j] = \min(
         dp[i-1][j] + 1,    \quad \text{（删除A的字符）} \\
         dp[i][j-1] + 1,    \quad \text{（插入B的字符）} \\
         dp[i-1][j-1] + 1   \quad \text{（替换字符）}
     )
     \]

4. **填表顺序**  
   从左上到右下逐行或逐列填充，最终结果在 \( dp[m][n] \)。

---

### **三、示例：计算 "kitten" → "sitting"**
|       | **0** | s    | i    | t    | t    | i    | n    | g    |
| ----- | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **0** | 0     | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| **k** | 1     | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| **i** | 2     | 2    | 1    | 2    | 3    | 4    | 5    | 6    |
| **t** | 3     | 3    | 2    | 1    | 2    | 3    | 4    | 5    |
| **t** | 4     | 4    | 3    | 2    | 1    | 2    | 3    | 4    |
| **e** | 5     | 5    | 4    | 3    | 2    | 2    | 3    | 4    |
| **n** | 6     | 6    | 5    | 4    | 3    | 3    | 2    | 3    |

最终编辑距离为 \( dp[6][7] = 3 \)，与预期一致。

---

### **四、动态规划的优化**
- **时间复杂度**：\( O(m \times n) \)，需填充 \( m \times n \) 的表格。
- **空间优化**：仅保留当前行和前一行，可将空间复杂度降至 \( O(n) \)。

---

### **五、应用场景**
1. **拼写纠错**：快速匹配用户输入与词典中的最近单词。
2. **基因序列比对**：计算DNA序列的相似性。
3. **版本控制**：比较文件差异。

---

### **六、变种与扩展**
- **加权编辑距离**：不同操作（插入、删除、替换）赋予不同权重。
- **Damerau-Levenshtein距离**：增加**相邻字符交换**操作（如 "ab" → "ba"）。

---

### **总结**
编辑距离通过动态规划将复杂问题分解为子问题，利用表格存储中间结果，避免重复计算，高效求解最优解。其核心在于状态定义和转移方程的合理设计，是动态规划的典型应用。



以下为之前讨论中所有动态规划案例的 **C/C++ 代码实现**，包含详细注释和测试用例：

---

### **1. 编辑距离（Levenshtein Distance）**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int editDistance(string word1, string word2) {
    int m = word1.size(), n = word2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // 初始化边界条件
    for (int i = 0; i <= m; i++) dp[i][0] = i;  // 删除i次
    for (int j = 0; j <= n; j++) dp[0][j] = j;  // 插入j次

    // 填表
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1[i - 1] == word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];  // 字符相同，无需操作
            } else {
                // 取插入、删除、替换的最小值 +1
                dp[i][j] = 1 + min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]});
            }
        }
    }
    return dp[m][n];
}

int main() {
    string word1 = "kitten", word2 = "sitting";
    cout << "Edit Distance: " << editDistance(word1, word2) << endl;  // 输出 3
    return 0;
}
```

---

### **2. 斐波那契数列（动态规划）**
```cpp
#include <iostream>
#include <vector>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) return n;
    vector<int> dp(n + 1);
    dp[0] = 0; dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

int main() {
    cout << "Fibonacci(10): " << fibonacci(10) << endl;  // 输出 55
    return 0;
}
```

---

### **3. 跳台阶问题（空间优化版）**
```cpp
#include <iostream>
using namespace std;

int climbStairs(int n) {
    if (n <= 2) return n;
    int a = 1, b = 2;  // a=dp[i-2], b=dp[i-1]
    for (int i = 3; i <= n; i++) {
        int c = a + b;  // dp[i] = dp[i-1] + dp[i-2]
        a = b;
        b = c;
    }
    return b;
}

int main() {
    cout << "Climb 5 Stairs: " << climbStairs(5) << endl;  // 输出 8
    return 0;
}
```

---

### **4. 0-1背包问题（空间优化版）**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int knapsack(int W, vector<int>& weights, vector<int>& values) {
    int n = weights.size();
    vector<int> dp(W + 1, 0);

    for (int i = 0; i < n; i++) {
        // 逆序更新防止重复计算
        for (int w = W; w >= weights[i]; w--) {
            dp[w] = max(dp[w], dp[w - weights[i]] + values[i]);
        }
    }
    return dp[W];
}

int main() {
    vector<int> weights = {2, 3, 4, 5};
    vector<int> values = {3, 4, 5, 6};
    int W = 8;
    cout << "Max Value: " << knapsack(W, weights, values) << endl;  // 输出 10
    return 0;
}
```

---

### **5. 最长公共子序列（LCS）**
```cpp
#include <iostream>
#include <vector>
using namespace std;

int longestCommonSubsequence(string text1, string text2) {
    int m = text1.size(), n = text2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}

int main() {
    string A = "ABCBDAB", B = "BDCAB";
    cout << "LCS Length: " << longestCommonSubsequence(A, B) << endl;  // 输出 4
    return 0;
}
```

---

### **代码说明**
1. **时间复杂度与空间复杂度**：
   - 编辑距离、LCS 和 0-1 背包问题的时间复杂度均为 \(O(mn)\)，空间复杂度 \(O(mn)\)（背包问题优化为 \(O(W)\)）。
   - 斐波那契和跳台阶的时间复杂度为 \(O(n)\)，空间复杂度优化至 \(O(1)\)。

2. **关键点**：
   - 状态转移方程严格对应问题逻辑。
   - 边界条件初始化（如编辑距离的第0行和第0列）。
   - 背包问题的逆序更新避免覆盖旧值。

---

以上代码可直接编译运行，如需进一步优化或扩展（如输出具体路径），可调整状态表记录方式。





Ref：

> https://chat.deepseek.com/a/chat/s/5b5861a2-bf1d-4a32-9e0a-1174c1ef42ed
> https://www.jianshu.com/p/4678d3f7b6f1
> https://time.geekbang.org/column/article/76183

